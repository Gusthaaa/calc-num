<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora Numérica Visual - Gauss e Bissecção</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f4f7f9;
            color: #333;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1 {
            color: #0056b3;
            text-align: center;
            margin-bottom: 10px;
        }
        h2 {
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
            color: #007bff;
            margin-top: 25px;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .input-group input[type="text"],
        .input-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            flex: 1;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .matrix-controls {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-bottom: 15px;
        }
        .matrix-controls button {
            flex: 0 1 auto; /* Botões não esticam */
            padding: 8px 15px;
            font-size: 14px;
        }
        .matrix-controls button.add { background-color: #28a745; }
        .matrix-controls button.add:hover { background-color: #218838; }
        .matrix-controls button.remove { background-color: #dc3545; }
        .matrix-controls button.remove:hover { background-color: #c82333; }
        #results-bissec, #results-gauss {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9f5ff;
            border-left: 5px solid #007bff;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }
        #bissec-chart-container {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: #f9f9f9;
            height: 350px;
            position: relative;
        }
        #matrix-container {
            display: grid;
            gap: 5px;
            margin-top: 10px;
        }
        #matrix-container input {
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <h1>Calculadora de Métodos Numéricos Visuais</h1>

    <div class="container">
        <h2>Método da Bissecção</h2>
        <div class="input-group">
            <label for="bissec-func">Função f(x):</label>
            <input type="text" id="bissec-func" value="x^3 - x - 2" placeholder="Ex: x^3 - 9*x + 3">
        </div>
        <div class="input-group">
            <label for="bissec-tol">Tolerância (ε):</label>
            <input type="number" id="bissec-tol" value="0.0001" step="0.00001">
        </div>
        <div class="button-group">
            <button onclick="iniciarBissec()">Iniciar/Resetar</button>
            <button id="nextBissecBtn" onclick="proximoPassoBissec()" disabled>Próximo Passo</button>
            <button id="runAllBissecBtn" onclick="executarTudoBissec()" disabled>Executar Tudo</button>
        </div>
        <div id="bissec-chart-container">
            <canvas id="bissecChart"></canvas>
        </div>
        <div id="results-bissec"></div>
    </div>

    <div class="container">
        <h2>Eliminação de Gauss</h2>
        <div class="matrix-controls">
            <button class="add" onclick="addGaussRow()">+ Adicionar Linha/Coluna</button>
            <button class="remove" onclick="removeGaussRow()">- Remover Linha/Coluna</button>
        </div>
        <p>Insira a matriz aumentada [A|B]:</p>
        <div id="matrix-container"></div>
        <br>
        <button onclick="calcularGauss()">Resolver Sistema</button>
        <div id="results-gauss"></div>
    </div>

    <script>
        // --- Variáveis globais para Bissecção ---
        let bisseccaoFunction = null;
        let currentA, currentB, currentTol;
        let bisseccaoChart = null;
        let iteracoesBisseccao = [];
        let chartPoints = [];
        let iteracaoAtualIndex = -1;

        // --- Variáveis globais e Lógica para Gauss ---
        let gaussMatrixSize = 3; // Inicia com 3x3

        // Função principal para desenhar a matriz de Gauss
        function renderGaussMatrix() {
            const container = document.getElementById('matrix-container');
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${gaussMatrixSize + 1}, 1fr)`;

            for (let i = 0; i < gaussMatrixSize; i++) {
                for (let j = 0; j < gaussMatrixSize + 1; j++) {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = `gauss_cell_${i}_${j}`;
                    input.placeholder = `a[${i+1}][${j+1}]`;
                    container.appendChild(input);
                }
            }
            // Desabilita o botão de remover se a matriz for 2x2
            document.querySelector('.matrix-controls .remove').disabled = (gaussMatrixSize <= 2);
        }

        // Funções dos botões de controle da matriz
        function addGaussRow() {
            if (gaussMatrixSize < 10) { // Limite máximo de 10x10
                gaussMatrixSize++;
                renderGaussMatrix();
            }
        }

        function removeGaussRow() {
            if (gaussMatrixSize > 2) { // Limite mínimo de 2x2
                gaussMatrixSize--;
                renderGaussMatrix();
            }
        }
        
        // Inicializa a matriz de Gauss na carga da página
        window.onload = function() {
            renderGaussMatrix();
        };

        // --- LÓGICA DO MÉTODO DA BISSECÇÃO (INALTERADO) ---
        function setupBissecChart(func, initialA, initialB) {
            const ctx = document.getElementById('bissecChart').getContext('2d');
            if (bisseccaoChart) {
                bisseccaoChart.destroy();
            }
            const plotPoints = [];
            let xMin = initialA - (initialB - initialA) * 0.2;
            let xMax = initialB + (initialB - initialA) * 0.2;
            let step = (xMax - xMin) / 100;
            for (let x = xMin; x <= xMax; x += step) {
                try { plotPoints.push({ x: x, y: func(x) }); } catch (e) {}
            }
            bisseccaoChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        { label: 'f(x)', data: plotPoints, borderColor: 'blue', borderWidth: 2, pointRadius: 0, showLine: true, fill: false },
                        { label: 'Intervalo [a, b]', data: [{ x: initialA, y: 0 }, { x: initialB, y: 0 }], borderColor: 'red', borderWidth: 2, pointRadius: 5, backgroundColor: 'red', showLine: true, type: 'line' },
                        { label: 'Ponto Médio (m)', data: [], borderColor: 'green', backgroundColor: 'green', pointRadius: 7, type: 'scatter' }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'linear', position: 'bottom', title: { display: true, text: 'x' }}, y: { type: 'linear', title: { display: true, text: 'f(x)' }}} }
            });
        }
        function iniciarBissec() {
            const funcStr = document.getElementById('bissec-func').value;
            currentA = -1000;
            currentB = 1000;
            currentTol = parseFloat(document.getElementById('bissec-tol').value);
            const resultsDiv = document.getElementById('results-bissec');
            resultsDiv.style.display = 'none';
            resultsDiv.innerHTML = '';
            document.getElementById('nextBissecBtn').disabled = true;
            document.getElementById('runAllBissecBtn').disabled = true;
            if (!funcStr || isNaN(currentTol)) {
                resultsDiv.textContent = "Erro: Preencha todos os campos corretamente.";
                resultsDiv.style.display = 'block';
                return;
            }
            try {
                const node = math.parse(funcStr);
                bisseccaoFunction = x => node.evaluate({x: x});
            } catch (err) {
                resultsDiv.textContent = "Erro na função: " + err.message;
                resultsDiv.style.display = 'block';
                return;
            }
            let fa = bisseccaoFunction(currentA);
            let fb = bisseccaoFunction(currentB);

            // Tenta encontrar um subintervalo dentro de [-1000, 1000] onde f(a) e f(b) tenham sinais opostos
            if (fa * fb >= 0) {
                let foundInterval = false;
                const step = 10; // Pode ajustar o passo conforme a necessidade
                for (let i = currentA; i < currentB; i += step) {
                    let tempA = i;
                    let tempB = i + step;
                    if (tempB > currentB) tempB = currentB; // Garante que não ultrapasse o limite superior

                    let tempFa = bisseccaoFunction(tempA);
                    let tempFb = bisseccaoFunction(tempB);

                    if (tempFa * tempFb < 0) {
                        currentA = tempA;
                        currentB = tempB;
                        fa = tempFa;
                        fb = tempFb;
                        foundInterval = true;
                        break;
                    }
                }
                if (!foundInterval) {
                    resultsDiv.textContent = "Erro: Não foi possível encontrar um intervalo [a, b] dentro de [-1000, 1000] onde f(a) * f(b) < 0. Tente uma função diferente ou um intervalo maior.";
                    resultsDiv.style.display = 'block';
                    return;
                }
            }
            iteracoesBisseccao = [{ a: currentA, b: currentB, fa: fa, fb: fb, m: null, fm: null }];
            iteracaoAtualIndex = 0;
            setupBissecChart(bisseccaoFunction, currentA, currentB);
            updateBissecChart(currentA, currentB, null);
            document.getElementById('nextBissecBtn').disabled = false;
            document.getElementById('runAllBissecBtn').disabled = false;
            resultsDiv.textContent = `Iteração 0: a = ${currentA.toFixed(6)}, b = ${currentB.toFixed(6)}, f(a)=${fa.toExponential(4)}, f(b)=${fb.toExponential(4)}`;
            resultsDiv.style.display = 'block';
        }
        function proximoPassoBissec() {
            if (!bisseccaoFunction || iteracaoAtualIndex >= 1000) {
                document.getElementById('nextBissecBtn').disabled = true;
                document.getElementById('runAllBissecBtn').disabled = true;
                return;
            }
            currentA = iteracoesBisseccao[iteracaoAtualIndex].a;
            currentB = iteracoesBisseccao[iteracaoAtualIndex].b;
            if ((currentB - currentA) / 2 <= currentTol) {
                document.getElementById('results-bissec').innerHTML += `\n\n<strong>Convergiu!</strong> Raiz aproximada: ${((currentA + currentB) / 2).toFixed(6)} em ${iteracaoAtualIndex} iterações.`;
                document.getElementById('nextBissecBtn').disabled = true;
                document.getElementById('runAllBissecBtn').disabled = true;
                return;
            }
            const m = (currentA + currentB) / 2;
            const fm = bisseccaoFunction(m);
            let nextA;
            let nextB;
            if (fm === 0) {
                nextA = m; 
                nextB = m;
            } else if (bisseccaoFunction(currentA) * fm < 0) { // Se f(a) e f(m) têm sinais opostos, a raiz está em [a, m]
                nextA = currentA;
                nextB = m;
            } else { // Se f(b) e f(m) têm sinais opostos, a raiz está em [m, b]
                nextA = m;
                nextB = currentB;
            }
            iteracoesBisseccao.push({ a: nextA, b: nextB, fa: bisseccaoFunction(nextA), fb: bisseccaoFunction(nextB), m: m, fm: fm });
            iteracaoAtualIndex++;
            updateBissecChart(currentA, currentB, m);
            document.getElementById('results-bissec').innerHTML += `\nIteração ${iteracaoAtualIndex}: a = ${currentA.toFixed(6)}, b = ${currentB.toFixed(6)}, m = ${m.toFixed(6)}, f(m)=${fm.toExponential(4)}`;
            if ((nextB - nextA) / 2 <= currentTol || fm === 0) {
                document.getElementById('results-bissec').innerHTML += `\n\n<strong>Convergiu!</strong> Raiz aproximada: ${((nextA + nextB) / 2).toFixed(6)} em ${iteracaoAtualIndex} iterações.`;
                document.getElementById('nextBissecBtn').disabled = true;
                document.getElementById('runAllBissecBtn').disabled = true;
            }
        }
        function executarTudoBissec() {
            document.getElementById('nextBissecBtn').disabled = true;
            document.getElementById('runAllBissecBtn').disabled = true;
            while (iteracaoAtualIndex < 1000 && !document.getElementById('nextBissecBtn').disabled) {
                proximoPassoBissec();
            }
        }
        function updateBissecChart(a, b, m) {
            bisseccaoChart.data.datasets[1].data = [{ x: a, y: 0 }, { x: b, y: 0 }];
            bisseccaoChart.data.datasets[2].data = m !== null ? [{ x: m, y: bisseccaoFunction(m) }] : [];
            bisseccaoChart.update();
        }

        // --- LÓGICA DA ELIMINAÇÃO DE GAUSS (ATUALIZADA) ---
        function calcularGauss() {
            const size = gaussMatrixSize;
            const matrix = [];
            const resultsDiv = document.getElementById('results-gauss');
            resultsDiv.style.display = 'none';
            resultsDiv.innerHTML = '';
            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size + 1; j++) {
                    const val = parseFloat(document.getElementById(`gauss_cell_${i}_${j}`).value);
                    if (isNaN(val)) {
                        resultsDiv.textContent = `Erro: Valor inválido na célula [${i+1}][${j+1}].`;
                        resultsDiv.style.display = 'block';
                        return;
                    }
                    matrix[i][j] = val;
                }
            }
            
            // --- INÍCIO DAS MODIFICAÇÕES ---
            const L = Array(size).fill(0).map(() => Array(size).fill(0));
            for(let i = 0; i < size; i++) L[i][i] = 1;
            let swapCount = 0;
            // --- FIM DAS MODIFICAÇÕES ---

            let resultText = "<strong>Matriz Original:</strong>\n" + formatMatrix(matrix, size) + "\n\n";
            
            for (let i = 0; i < size; i++) {
                let maxRow = i;
                for (let k = i + 1; k < size; k++) {
                    if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
                        maxRow = k;
                    }
                }
                if (maxRow !== i) {
                    swapCount++; // CONTA A TROCA DE LINHAS
                    [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
                    resultText += `<strong>Troca de Linhas (pivoteamento): L${i+1} <-> L${maxRow+1}</strong>\n` + formatMatrix(matrix, size) + "\n\n";
                }
                if (matrix[i][i] === 0) {
                    resultsDiv.textContent = "Erro: Pivô zero encontrado. O sistema pode não ter solução única (Determinante é zero).";
                    resultsDiv.style.display = 'block';
                    return;
                }
                for (let k = i + 1; k < size; k++) {
                    const factor = matrix[k][i] / matrix[i][i];
                    L[k][i] = factor; // ARMAZENA O FATOR NA MATRIZ L
                    for (let j = i; j < size + 1; j++) {
                        matrix[k][j] -= factor * matrix[i][j];
                    }
                    resultText += `<strong>Operação: L${k+1} = L${k+1} - (${factor.toFixed(4)})*L${i+1}</strong>\n` + formatMatrix(matrix, size) + "\n\n";
                }
            }

            // --- INÍCIO DAS MODIFICAÇÕES PARA EXIBIÇÃO ---
            const U = Array(size).fill(0).map((_, r) =>
                Array(size).fill(0).map((__, c) => (r <= c ? matrix[r][c] : 0))
            );

            let det = Math.pow(-1, swapCount);
            for (let i = 0; i < size; i++) {
                det *= U[i][i];
            }

            resultText += "<strong>--- Fatoração LU e Determinante ---</strong>\n\n";
            resultText += formatSquareMatrix(L, size, "L");
            resultText += "\n";
            resultText += formatSquareMatrix(U, size, "U");
            resultText += "\n";
            resultText += `<strong>Determinante de A (det(U) * (-1)^trocas):</strong> ${det.toFixed(6)}\n\n`;
            resultText += "<strong>--- Resolução do Sistema ---</strong>\n\n";
            // --- FIM DAS MODIFICAÇÕES PARA EXIBIÇÃO ---

            resultText += "<strong>Matriz Aumentada Triangularizada Final:</strong>\n" + formatMatrix(matrix, size) + "\n\n";
            
            const solution = new Array(size);
            for (let i = size - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < size; j++) {
                    sum += matrix[i][j] * solution[j];
                }
                solution[i] = (matrix[i][size] - sum) / matrix[i][i];
            }
            resultText += "<strong>Solução encontrada (x):</strong>\n\n";
            solution.forEach((val, index) => {
                resultText += `x${index + 1} = ${val.toFixed(6)}\n`;
            });
            resultsDiv.innerHTML = resultText;
            resultsDiv.style.display = 'block';
        }

        function formatMatrix(mat, size) {
            let str = "";
            for (let i = 0; i < size; i++) {
                str += "[";
                for (let j = 0; j < size; j++) {
                    str += mat[i][j].toFixed(4).padStart(10) + (j < size - 1 ? ", " : "");
                }
                str += " | " + mat[i][size].toFixed(4).padStart(10) + "]\n";
            }
            return str;
        }

        // --- NOVA FUNÇÃO ADICIONADA ---
        function formatSquareMatrix(mat, size, name) {
            let str = `<strong>Matriz ${name}:</strong>\n`;
            for (let i = 0; i < size; i++) {
                str += "[";
                for (let j = 0; j < size; j++) {
                    str += mat[i][j].toFixed(4).padStart(10) + (j < size - 1 ? ", " : "");
                }
                str += "]\n";
            }
            return str;
        }

    </script>
</body>
</html>
